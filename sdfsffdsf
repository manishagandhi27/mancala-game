def merge_tables_accurately(tables, is_pdf=True):
    """
    Merge multi-page tables for both PDFs and Word documents without skipping valid continuation tables.
    Avoid merging unrelated tables and ensure all continuation tables are included.
    """
    merged_tables = []
    current_table = None
    reference_header = None
    last_row_offset = 0
    last_column_count = None
    last_page = None

    for table in tables:
        cells = table['data']['table_cells']
        current_page = table['prov'].get('page_no') if is_pdf else None  # Use page number if available (for PDFs)
        current_column_count = max(cell['start_col_offset_idx'] for cell in cells) + 1
        has_column_header = any(cell.get('column_header', False) for cell in cells)
        current_header = extract_header(cells) if has_column_header else None

        if current_table is None:
            # First table, initialize the merging context
            current_table = create_new_table(table, cells)
            reference_header = current_header
            last_row_offset = max(cell['end_row_offset_idx'] for cell in cells) + 1
            last_column_count = current_column_count
            last_page = current_page
        else:
            # Merge logic based on document type
            if (is_pdf and current_page == last_page + 1) or (not is_pdf and current_column_count == last_column_count):
                # Multi-page continuation based on structure
                if is_wrong_header(current_header, reference_header):
                    # Continuation detected—merge without skipping
                    for cell in cells:
                        cell['start_row_offset_idx'] += last_row_offset
                        cell['end_row_offset_idx'] += last_row_offset
                        current_table['data']['table_cells'].append(cell)
                    last_row_offset = max(cell['end_row_offset_idx'] for cell in cells) + 1
                    last_page = current_page
                else:
                    # Different table structure—append current table and start a new one
                    merged_tables.append(current_table)
                    current_table = create_new_table(table, cells)
                    reference_header = current_header
                    last_row_offset = max(cell['end_row_offset_idx'] for cell in cells) + 1
                    last_column_count = current_column_count
                    last_page = current_page
            else:
                # New table detected—append current table and reset merging context
                merged_tables.append(current_table)
                current_table = create_new_table(table, cells)
                reference_header = current_header
                last_row_offset = max(cell['end_row_offset_idx'] for cell in cells) + 1
                last_column_count = current_column_count
                last_page = current_page

    # Add the last merged table
    if current_table:
        merged_tables.append(current_table)
    return merged_tables


def create_new_table(table, cells):
    """ Create a new table with the given cells and metadata. """
    return {
        "data": {
            "table_cells": cells
        },
        "prov": table.get("prov", {})
    }


def extract_header(cells):
    """ Extract the first row as a header for comparison. """
    return [cell['text'].strip() for cell in cells if cell['start_row_offset_idx'] == 0]


def is_wrong_header(current_header, reference_header):
    """
    Detect if the current header is incorrect by comparing it with the reference header.
    Continuation tables might have no header or fewer columns.
    """
    if not current_header or not reference_header:
        return False  # No header indicates a likely continuation
    if len(current_header) < len(reference_header):
        return True  # Likely a wrong header
    return current_header != reference_header


# Example usage with fragmented tables simulating multi-page tables
fragmented_tables = [
    {
        "data": {
            "table_cells": [
                {"start_row_offset_idx": 0, "start_col_offset_idx": 0, "text": "Customer", "column_header": True},
                {"start_row_offset_idx": 0, "start_col_offset_idx": 1, "text": "Order ID", "column_header": True},
                {"start_row_offset_idx": 1, "start_col_offset_idx": 0, "text": "John Doe"},
                {"start_row_offset_idx": 1, "start_col_offset_idx": 1, "text": "1234"}
            ]
        },
        "prov": {"page_no": 1}
    },
    {
        "data": {
            "table_cells": [
                {"start_row_offset_idx": 0, "start_col_offset_idx": 0, "text": "Jane Smith"},
                {"start_row_offset_idx": 0, "start_col_offset_idx": 1, "text": "5678"}
            ]
        },
        "prov": {"page_no": 2}
    },
    {
        "data": {
            "table_cells": [
                {"start_row_offset_idx": 0, "start_col_offset_idx": 0, "text": "Product", "column_header": True},
                {"start_row_offset_idx": 0, "start_col_offset_idx": 1, "text": "Price", "column_header": True},
     
