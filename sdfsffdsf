def merge_multipage_tables(doc):
    """
    Merge multipage tables from a document (dict) according to these rules:
      1. Do not merge tables on the same page (use table["prov"]["page_no"]).
      2. Merge tables from consecutive pages if the elements between their
         occurrences (in the "body" order) are either page_header, page_footer, or a picture.
      3. Use the order from the "body" list.
    """
    # Build lookup dictionaries.
    texts_lookup = { text["self_ref"]: text for text in doc.get("texts", []) }
    tables_lookup = { table["self_ref"]: table for table in doc.get("tables", []) }
    pictures_lookup = { pic["self_ref"]: pic for pic in doc.get("pictures", []) } if "pictures" in doc else {}

    # Get the ordered list of $ref values from "body"
    body_elements = doc.get("body", [])
    body_refs = [el["$ref"] for el in body_elements]

    # Build a list of positions for table references in the body.
    table_positions = []
    for idx, ref in enumerate(body_refs):
        if ref.startswith("#/tables/"):
            table_positions.append((idx, ref))

    merged_table_groups = []  # each group is a list of table dicts that will be merged together.
    i = 0
    while i < len(table_positions):
        start_index, table_ref = table_positions[i]
        current_table = tables_lookup.get(table_ref)
        current_group = [current_table]
        current_page_no = current_table["prov"]["page_no"]
        pos = start_index  # last position of a table in body that was merged

        # Look ahead for tables that might be continuations.
        j = i + 1
        while j < len(table_positions):
            next_index, next_table_ref = table_positions[j]
            next_table = tables_lookup.get(next_table_ref)
            next_page_no = next_table["prov"]["page_no"]

            # Rule 1: Do not merge if tables are on the same page.
            if next_page_no == current_page_no:
                break

            # Only consider consecutive page numbers.
            if next_page_no == current_page_no + 1:
                allowed = True
                # Check intervening elements between last table and next table.
                for k in range(pos + 1, next_index):
                    in_between_ref = body_refs[k]
                    # Adjust the check to catch both "#/texts/" and "#/text/"
                    if in_between_ref.startswith("#/texts/") or in_between_ref.startswith("#/text/"):
                        # Lookup text element; if label isn't header/footer, disallow merge.
                        text_obj = texts_lookup.get(in_between_ref.replace("#/text/", "#/texts/"), {})
                        if text_obj.get("label") not in ["page_header", "page_footer"]:
                            allowed = False
                            break
                    elif in_between_ref.startswith("#/tables/"):
                        # If another table appears, that's unexpected here.
                        allowed = False
                        break
                    elif in_between_ref.startswith("#/picture/"):
                        # Pictures are allowed.
                        continue
                    else:
                        # Unknown element; disallow.
                        allowed = False
                        break

                if allowed:
                    # Merge this table by adding it to the group.
                    current_group.append(next_table)
                    pos = next_index
                    current_page_no = next_page_no
                    j += 1  # Move to the next candidate.
                else:
                    break
            else:
                # Not consecutive pages.
                break
        merged_table_groups.append(current_group)
        i = j  # Continue from the next unchecked table

    # Build new table list: if a group has multiple tables, merge them.
    new_tables = []
    for group in merged_table_groups:
        if len(group) == 1:
            new_tables.append(group[0])
        else:
            merged_table = merge_tables_in_group(group)
            new_tables.append(merged_table)
    
    # Update document.
    doc["tables"] = new_tables
    return doc


def merge_tables_in_group(group):
    """
    Merge a list of table dictionaries by concatenating their table_cells.
    (Additional logic—such as handling duplicate headers—can be added as needed.)
    """
    merged_cells = []
    for table in group:
        cells = table.get("data", {}).get("table_cells", [])
        merged_cells.extend(cells)
    
    merged_table = {
        "data": {"table_cells": merged_cells},
        # Retain provenance from the first table.
        "prov": group[0]["prov"],
        # Create a new self_ref to indicate it is merged.
        "self_ref": group[0]["self_ref"] + "_merged"
    }
    return merged_table


# ===== Example Usage =====
if __name__ == "__main__":
    # Example document simulating the problematic scenario:
    # Page 1: table 1, Page 2: table 2, then some non-header text, then table 3.
    doc = {
        "body": [
            {"$ref": "#/tables/0"},
            {"$ref": "#/tables/1"},
            {"$ref": "#/texts/99"},   # Some text that's not a header/footer.
            {"$ref": "#/tables/2"}
        ],
        "texts": [
            {
                "self_ref": "#/texts/99",
                "parent": {"$ref": "#/body"},
                "children": [],
                "label": "body_text",  # Not allowed for merging.
                "prov": [{"page_no": 2}],
                "orig": "Some paragraph text",
                "text": "This is a normal paragraph."
            }
        ],
        "tables": [
            {
                "data": {
                    "table_cells": [
                        {"start_row_offset_idx": 0, "start_col_offset_idx": 0, "text": "Customer", "column_header": True},
                        {"start_row_offset_idx": 0, "start_col_offset_idx": 1, "text": "Order ID", "column_header": True},
                        {"start_row_offset_idx": 1, "start_col_offset_idx": 0, "text": "John Doe"},
                        {"start_row_offset_idx": 1, "start_col_offset_idx": 1, "text": "1234"}
                    ]
                },
                "prov": {"page_no": 1},
                "self_ref": "#/tables/0"
            },
            {
                "data": {
                    "table_cells": [
                        {"start_row_offset_idx": 0, "start_col_offset_idx": 0, "text": "Jane Smith"},
                        {"start_row_offset_idx": 0, "start_col_offset_idx": 1, "text": "5678"}
                    ]
                },
                "prov": {"page_no": 2},
                "self_ref": "#/tables/1"
            },
            {
                "data": {
                    "table_cells": [
                        {"start_row_offset_idx": 0, "start_col_offset_idx": 0, "text": "Product", "column_header": True},
                        {"start_row_offset_idx": 0, "start_col_offset_idx": 1, "text": "Price", "column_header": True},
                        {"start_row_offset_idx": 1, "start_col_offset_idx": 0, "text": "Laptop"},
                        {"start_row_offset_idx": 1, "start_col_offset_idx": 1, "text": "$1000"}
                    ]
                },
                "prov": {"page_no": 3},
                "self_ref": "#/tables/2"
            }
        ],
        "pictures": [
            {
                "self_ref": "#/picture/5",
                "label": "picture",
                # additional picture properties...
            }
        ]
    }

    merged_doc = merge_multipage_tables(doc)
    import json
    print(json.dumps(merged_doc, indent=2))
