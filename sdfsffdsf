def merge_tables_with_structure_validation(tables):
    """ Merge tables only if they have consistent column count and structure, preserving unrelated tables. """
    merged_tables = []
    current_table = {
        "data": {
            "table_cells": []
        }
    }
    last_column_count = None
    last_row_offset = 0

    for table in tables:
        cells = table['data']['table_cells']
        
        # Calculate current table column count
        current_column_count = max(cell['start_col_offset_idx'] for cell in cells) + 1

        if last_column_count is None:
            # First table, initialize the merging context
            last_column_count = current_column_count
            current_table['data']['table_cells'].extend(cells)
            last_row_offset = max(cell['end_row_offset_idx'] for cell in cells) + 1
        elif current_column_count == last_column_count:
            # Likely a continuation of the previous table
            for cell in cells:
                cell['start_row_offset_idx'] += last_row_offset
                cell['end_row_offset_idx'] += last_row_offset
                current_table['data']['table_cells'].append(cell)
            last_row_offset = max(cell['end_row_offset_idx'] for cell in cells) + 1
        else:
            # Column count mismatch, treat it as a new table
            merged_tables.append(current_table)
            current_table = {
                "data": {
                    "table_cells": cells
                }
            }
            last_column_count = current_column_count
            last_row_offset = max(cell['end_row_offset_idx'] for cell in cells) + 1

    # Add the last merged table
    merged_tables.append(current_table)
    return merged_tables


# Example usage with multiple tables of varying structures
fragmented_tables = [
    {
        "data": {
            "table_cells": [
                {"start_row_offset_idx": 0, "start_col_offset_idx": 0, "text": "Value A"},
                {"start_row_offset_idx": 0, "start_col_offset_idx": 1, "text": "Value B"}
            ]
        }
    },
    {
        "data": {
            "table_cells": [
                {"start_row_offset_idx": 0, "start_col_offset_idx": 0, "text": "Header 1"},
                {"start_row_offset_idx": 0, "start_col_offset_idx": 1, "text": "Header 2"},
                {"start_row_offset_idx": 0, "start_col_offset_idx": 2, "text": "Header 3"},
                {"start_row_offset_idx": 0, "start_col_offset_idx": 3, "text": "Header 4"},
                {"start_row_offset_idx": 0, "start_col_offset_idx": 4, "text": "Header 5"},
                {"start_row_offset_idx": 1, "start_col_offset_idx": 0, "text": "Row 1"}
            ]
        }
    },
    {
        "data": {
            "table_cells": [
                {"start_row_offset_idx": 0, "start_col_offset_idx": 0, "text": "Data 1"},
                {"start_row_offset_idx": 0, "start_col_offset_idx": 1, "text": "Data 2"},
                {"start_row_offset_idx": 0, "start_col_offset_idx": 2, "text": "Data 3"},
                {"start_row_offset_idx": 0, "start_col_offset_idx": 3, "text": "Data 4"}
            ]
        }
    }
]

# Merge tables with structure validation
merged_tables = merge_tables_with_structure_validation(fragmented_tables)

import json
print(json.dumps(merged_tables, indent=2))
